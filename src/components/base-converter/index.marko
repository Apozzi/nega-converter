import { DIGITS, BASE_OPTIONS, getBaseDisplayName } from "./base-converter-utils"; 
import './style.scss'

class {
    state = {
        inputValue: "10",
        outputValue: "",
        fromBase: 10,
        toBase: 2,
        error: null,
        allowedCharsRegex: /^[0-9A-F]$/i,
        activeInput: 'from'
    }

    onCreate() {
        this.updateAllowedCharsRegex('from', this.state.base);
        this.calculateOutputValue(this.state.inputValue, this.state.fromBase, this.state.toBase);
    }

    convertDecimalToBase(dec, base) {
        if (isNaN(dec)) return { error: "Decimal inválido" };
        if (base > 1) {
            return this.decimalToPositiveBase(dec, base);
        } else if (base < -1) {
            return this.decimalToNegativeBase(dec, base);
        } else {
            return { error: `Base ${base} inválida` };
        }
    }

    decimalToPositiveBase(dec, base) {
        if (dec === 0) return { value: "0" };

        let result = "";
        let isNegative = dec < 0;
        if (isNegative) dec = -dec;

        while (dec > 0) {
            let remainder = dec % base;
            result = DIGITS[remainder] + result;
            dec = Math.floor(dec / base);
        }

        return { value: (isNegative ? "-" : "") + result };
    }

    decimalToNegativeBase(dec, base) {
        if (dec === 0) return { value: "0" };
        if (base >= -1) return { error: `Base ${base} inválida para negabase` };

        let result = "";
        let currentDec = dec;
        const absBase = Math.abs(base);

        while (currentDec !== 0) {
            let remainder = currentDec % base;

            if (remainder < 0) {
                remainder += absBase;
            }
            if (remainder < 0 || remainder >= absBase) {
                return { error: "Erro interno no cálculo da negabase." };
            }
            result = DIGITS[remainder] + result;
            currentDec = (currentDec - remainder) / base;
            if (!Number.isInteger(currentDec)) {
                return { error: "Erro interno no cálculo do quociente." };
            }
        }
        return { value: result };
    }


    convertBaseToDecimal(baseStr, base) {
        baseStr = baseStr.toUpperCase();
        if (base > 1) {
            return this.positiveBaseToDecimal(baseStr, base);
        } else if (base < -1) {
            return this.negativeBaseToDecimal(baseStr, base);
        } else {
            return { error: `Base ${base} inválida` };
        }
    }

    positiveBaseToDecimal(baseStr, base) {
        let isNegative = false;
        if (baseStr.startsWith('-')) {
            isNegative = true;
            baseStr = baseStr.substring(1);
        }

        let decimal = 0;
        let power = 0;

        for (let i = baseStr.length - 1; i >= 0; i--) {
            const char = baseStr[i];
            const digitValue = DIGITS.indexOf(char);

            if (digitValue === -1 || digitValue >= base) return { error: `Dígito '${char}' inválido para base ${base}` };
            decimal += digitValue * Math.pow(base, power);
            power++;
        }
        return { value: (isNegative ? -decimal : decimal).toString() };
    }

    negativeBaseToDecimal(baseStr, base) {
        let decimal = 0;
        let power = 0;

        for (let i = baseStr.length - 1; i >= 0; i--) {
            const char = baseStr[i];
            const digitValue = DIGITS.indexOf(char);
            if (digitValue === -1 || digitValue >= Math.abs(base)) return { error: `Dígito '${char}' inválido para base ${base}` };

            decimal += digitValue * Math.pow(base, power);
            power++;
        }
        return { value: decimal.toString() };
    }

    handleFromBaseChange(event) {
        const newBase = parseInt(event.target.value, 10);
        this.state.fromBase = newBase;
        this.updateAllowedCharsRegex('from', newBase);
        this.calculateOutputValue(this.state.inputValue, newBase, this.state.toBase);
    }

    handleToBaseChange(event) {
        const newBase = parseInt(event.target.value, 10);
        this.state.toBase = newBase;
        this.calculateOutputValue(this.state.inputValue, this.state.fromBase, newBase);
    }

    processInputValue(value, base) {
        const cleanedValue = value.replace(/[\r\n]+/g, '');
        if (cleanedValue === '-' && base > 1) return '-';
        if (cleanedValue === '') return '';
        const absBase = Math.abs(base);
        const allowedChars = DIGITS.substring(0, absBase);
        const regexStr = `^-?[${allowedChars}]*$`;
        const regex = new RegExp(regexStr, 'i');
        if (!regex.test(cleanedValue)) return null;
        return cleanedValue.toUpperCase();
    }

    handleInputChange(event) {
        const rawValue = event.target.value;
        const isFromInput = event.target.id === 'from-input';
        const currentBase = isFromInput ? this.state.fromBase : this.state.toBase;
        const processedValue = this.processInputValue(rawValue, currentBase);

        if (processedValue === null) {
            event.target.value = isFromInput ? this.state.inputValue : this.state.outputValue;
            return;
        }

        if (isFromInput) {
            this.state.inputValue = processedValue;
            this.calculateOutputValue(processedValue, this.state.fromBase, this.state.toBase);
        } else {
            this.state.outputValue = processedValue;
            this.calculateInputValue(processedValue, this.state.toBase, this.state.fromBase);
        }
        this.state.activeInput = isFromInput ? 'from' : 'to';
    }

    calculateOutputValue(inputValue, fromBase, toBase) {
        if (inputValue === '') {
            this.state.outputValue = '';
            this.state.error = null;
            return;
        }

        const decimalResult = this.convertBaseToDecimal(inputValue, fromBase);

        if (decimalResult.error) {
            this.state.error = decimalResult.error;
            this.state.outputValue = 'Erro';
            return;
        }

        const decimalValue = parseFloat(decimalResult.value);
        if (isNaN(decimalValue) || !Number.isInteger(decimalValue)) {
            if (inputValue.trim() !== '' && inputValue !== '-') {
                this.state.error = 'Valor de entrada inválido para a base selecionada.';
            } else {
                this.state.error = null;
            }
            this.state.outputValue = '';
            return;
        }

        const resultToBase = this.convertDecimalToBase(decimalValue, toBase);
        if (resultToBase.error) {
            this.state.error = resultToBase.error;
            this.state.outputValue = 'Erro';
        } else {
            this.state.error = null;
            this.state.outputValue = resultToBase.value;
        }
    }

    calculateInputValue(outputValue, toBase, fromBase) {
        if (outputValue === '') {
            this.state.inputValue = '';
            this.state.error = null;
            return;
        }

        const decimalResult = this.convertBaseToDecimal(outputValue, toBase);

        if (decimalResult.error) {
            this.state.error = decimalResult.error;
            this.state.inputValue = 'Erro';
            return;
        }

        const decimalValue = parseFloat(decimalResult.value);
        if (isNaN(decimalValue) || !Number.isInteger(decimalValue)) {
            if (outputValue.trim() !== '' && outputValue !== '-') {
                this.state.error = 'Valor de saída inválido para a base selecionada.';
            } else {
                this.state.error = null;
            }
            this.state.inputValue = '';
            return;
        }

        const resultFromBase = this.convertDecimalToBase(decimalValue, fromBase);
        if (resultFromBase.error) {
            this.state.error = resultFromBase.error;
            this.state.inputValue = 'Erro';
        } else {
            this.state.error = null;
            this.state.inputValue = resultFromBase.value;
        }
    }

    updateAllowedCharsRegex(base) {
        const absBase = Math.abs(base);
        const allowed = DIGITS.substring(0, absBase);
        const regex = new RegExp(`^[${allowed}]$`, 'i');
        this.setState('allowedCharsRegex', regex);
    }

    handleSwapBases() {
        const tempFromBase = this.state.fromBase;
        const tempToBase = this.state.toBase;
        const tempInputValue = this.state.inputValue;
        const tempOutputValue = this.state.outputValue;

        this.state.fromBase = tempToBase;
        this.state.toBase = tempFromBase;
        this.state.inputValue = tempOutputValue;
        this.state.outputValue = tempInputValue;
        this.state.error = null;
        this.state.activeInput = this.state.activeInput === 'from' ? 'to' : 'from';
        this.update();
    }
}


<div.converter-container>
    <h1.converter-title>Conversor de Bases Numéricas</h1>
    <div.base-selector>
        <label for="base-select">Converter de</label>
        <select id="from-base-select" value=state.fromBase onChange('handleFromBaseChange')>
            <for|baseNum| of=BASE_OPTIONS>
                <option value=baseNum selected=(baseNum === state.fromBase)>
                   Base ${baseNum} (${getBaseDisplayName(baseNum)})
                </option>
            </for>
        </select>
        <label for="base-select">para</label>
        <select id="to-base-select" value=state.toBase onChange('handleToBaseChange')>
            <for|baseNum| of=BASE_OPTIONS>
                <option value=baseNum selected=(baseNum === state.toBase)>
                    Base ${baseNum} ${getBaseDisplayName(baseNum, true)}
                </option>
            </for>
        </select>

        <button
            id="swap-button"
            class="swap-button"
            onClick('handleSwapBases')
            aria-label="Inverter bases e valores"
            title="Inverter bases e valores">
                ⇄
        </button>
    </div>

    <div.inputs-area>
      <div.input-card>
        <label for="from-input">${getBaseDisplayName(state.fromBase) || (`Base ${state.fromBase}`)}</label>
        <textarea
            id="from-input"
            key="from-input"
            rows="2"
            value=state.inputValue
            onInput('handleInputChange')
            placeholder="Digite o valor"
            autocomplete="off"
            spellcheck="false"
        >${state.inputValue}</textarea>
      </div>

      <div.input-card>
        <label for="to-input">${getBaseDisplayName(state.toBase) || (`Base ${state.toBase}`)}</label>
        <textarea
            id="to-input"
            key="to-input"
            rows="2"
            value=state.outputValue
            readonly
            placeholder="Resultado"
            spellcheck="false"
            autocomplete="off"
        >${state.outputValue}</textarea>
      </div>
    </div>
</div.converter-container>

